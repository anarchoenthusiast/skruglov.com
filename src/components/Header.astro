---
import Container from "@components/Container.astro";
import Logo from "@components/Logo.astro";
import Breadcrumb from "@components/Breadcrumb.astro";
import { SITE } from "@consts";

interface Props {
  pageType?: 'default' | 'blog' | 'project';
  breadcrumbs?: {
    label: string;
    url?: string;
  }[];
}

const { pageType = 'default', breadcrumbs = [] } = Astro.props;

// Мапим pageType на размер контейнера
const containerSize = pageType === 'blog' ? 'blog-mobile' : pageType;

// Строим хлебные крошки
const defaultBreadcrumbs = [
  { label: SITE.NAME, url: '/' }
];

// Если хлебные крошки не заданы явно, формируем их на основе текущего пути
const currentPath = Astro.url.pathname;
let finalBreadcrumbs = breadcrumbs.length > 0 ? breadcrumbs : defaultBreadcrumbs;

// Добавляем текущий путь, если хлебные крошки не заданы явно
if (breadcrumbs.length === 0 && currentPath !== '/') {
  const segments = currentPath.split('/').filter(segment => segment);
  
  if (segments.length > 0) {
    const pathSegment = segments[0];
    const label = pathSegment.charAt(0).toUpperCase() + pathSegment.slice(1);
    finalBreadcrumbs.push({
      label: label,
      // Для страниц верхнего уровня (/projects, /blog, /about, /colophon) не делаем ссылку
      // чтобы показать второй уровень (текущий путь) как текущую страницу
      url: ['projects', 'blog', 'about', 'colophon'].includes(pathSegment) ? undefined : `/${pathSegment}`
    });
  }
}

// Определяем, нужно ли показывать последний элемент в хлебных крошках
// Для страниц верхнего уровня показываем его
const normalizedPath = currentPath.endsWith('/') && currentPath !== '/' ? currentPath.slice(0, -1) : currentPath;
const showLast = normalizedPath === '/projects' || normalizedPath === '/blog' || normalizedPath === '/about' || normalizedPath === '/colophon';
---

<header class="pt-12">
  <Container size={containerSize}>
    <div class="flex items-center justify-between">
      <div class="flex items-center gap-2">
        <a href="/" class="hover:opacity-80 transition-opacity cursor-pointer">
          <Logo />
        </a>
        <Breadcrumb items={finalBreadcrumbs} showLastItem={showLast} />
      </div>
    </div>
  </Container>
</header>

<script is:inline>
  function initCloseButton() {
    // Удаляем предыдущую кнопку если она есть
    const existingButton = document.getElementById('header-close-button');
    if (existingButton) {
      existingButton.remove();
    }
    
    // Проверяем, нужна ли кнопка закрытия
    const urlParams = new URLSearchParams(window.location.search);
    const fromSource = urlParams.get('from');
    const referrer = document.referrer;
    const currentDomain = window.location.origin;
    
    // Проверяем сохраненные источники в sessionStorage
    const savedProjectSource = sessionStorage.getItem('projectNavigationSource');
    const savedBlogSource = sessionStorage.getItem('blogNavigationSource');
    const savedSource = savedProjectSource || savedBlogSource;
    
    // Упрощенная логика: показываем кнопку если есть параметр from ИЛИ сохраненный источник ИЛИ есть история браузера
    const hasFromParam = fromSource === 'home' || fromSource === 'projects' || fromSource === 'blog';
    const hasHistory = window.history.length > 1;
    const isFromOurSite = referrer && referrer.startsWith(currentDomain);
    
    const shouldShowButton = hasFromParam || savedSource || (hasHistory && isFromOurSite);
    
    // Определяем финальный источник для кнопки - приоритет сохраненному значению
    const finalSource = savedSource || fromSource || 'home';
    
    // Сохраняем источник ТОЛЬКО если его еще нет в sessionStorage
    if (hasFromParam && !savedSource) {
      if (window.location.pathname.startsWith('/blog/')) {
        sessionStorage.setItem('blogNavigationSource', fromSource);
      } else if (window.location.pathname.startsWith('/projects/')) {
        sessionStorage.setItem('projectNavigationSource', fromSource);
      }
    }
    
    console.log('Close button check:', {
      url: window.location.href,
      fromSource: fromSource,
      savedSource: savedSource,
      finalSource: finalSource,
      referrer: referrer,
      currentDomain: currentDomain,
      hasFromParam: hasFromParam,
      hasHistory: hasHistory,
      historyLength: window.history.length,
      isFromOurSite: isFromOurSite,
      shouldShow: shouldShowButton
    });
    
    // Дополнительное логирование для отладки
    if (hasFromParam) {
      console.log('✅ Found from parameter:', fromSource);
    } else {
      console.log('❌ No from parameter found');
    }
    
    if (savedSource) {
      console.log('✅ Found saved source:', savedSource);
    } else {
      console.log('❌ No saved source found');
    }
    
    if (!shouldShowButton) {
      console.log('Close button not needed, exiting');
      return;
    }
    
    console.log('Creating close button...');
    
    // Создаем кнопку
    const closeButton = document.createElement('button');
    closeButton.id = 'header-close-button';
    closeButton.className = 'header-close-button';
    closeButton.setAttribute('data-from-source', finalSource);
    closeButton.innerHTML = `
      <svg width="22" height="24" viewBox="0 0 22 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M15.75 16.25L7.25 7.75" stroke="currentColor" stroke-opacity="0.44" stroke-linecap="round"/>
        <path d="M7.25 16.25L15.75 7.75" stroke="currentColor" stroke-opacity="0.44" stroke-linecap="round"/>
      </svg>
    `;
    
    // Применяем стили напрямую - делаем кнопку fixed но на уровне хедера
    const isDark = document.documentElement.classList.contains('dark') || 
                  window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    Object.assign(closeButton.style, {
      position: 'fixed',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      width: '34px',
      height: '34px',
      padding: '5px',
      background: isDark ? 'rgba(20, 20, 20, 0.4)' : 'rgba(235, 235, 235, 0.4)',
      backdropFilter: 'blur(24px)',
      border: 'none',
      borderRadius: '9999px',
      color: isDark ? 'rgb(248, 248, 248)' : 'rgb(7, 7, 7)',
      cursor: 'pointer',
      transition: 'all 0.2s ease-in-out',
      userSelect: 'none',
      overflow: 'hidden',
      fontFamily: '"Die Grotesk B", sans-serif',
      fontWeight: '400',
      fontSize: '16px',
      lineHeight: '1.5',
      zIndex: '50'
    });
    
    // Hover эффекты
    closeButton.addEventListener('mouseenter', function() {
      const isDark = document.documentElement.classList.contains('dark') || 
                    window.matchMedia('(prefers-color-scheme: dark)').matches;
      closeButton.style.background = isDark ? 'rgba(20, 20, 20, 0.6)' : 'rgba(235, 235, 235, 0.6)';
    });
    
    closeButton.addEventListener('mouseleave', function() {
      const isDark = document.documentElement.classList.contains('dark') || 
                    window.matchMedia('(prefers-color-scheme: dark)').matches;
      closeButton.style.background = isDark ? 'rgba(20, 20, 20, 0.4)' : 'rgba(235, 235, 235, 0.4)';
    });
    
    // Добавляем в body как fixed элемент
    document.body.appendChild(closeButton);
    
    function setButtonPosition() {
      const headerContainer = document.querySelector('header .mx-auto');
      
      if (!headerContainer) return;
      
      // Определяем позицию по скроллу
      const scrollTop = window.scrollY;
      const topPosition = scrollTop > 10 ? '24px' : '48px';
      
      // На мобильных устройствах используем фиксированный отступ 24px
      const isMobile = window.innerWidth <= 768;
      let rightPosition;
      
      if (isMobile) {
        rightPosition = '24px';
      } else {
        const containerRect = headerContainer.getBoundingClientRect();
        const rightOffset = window.innerWidth - containerRect.right;
        rightPosition = rightOffset + 'px';
      }
      
      closeButton.style.top = topPosition; 
      closeButton.style.right = rightPosition;
    }
    
    // Устанавливаем позицию при загрузке
    setTimeout(setButtonPosition, 100);
    
    // Обновляем при ресайзе окна
    window.addEventListener('resize', setButtonPosition);
    
    // Обновляем при скролле
    window.addEventListener('scroll', setButtonPosition);
    
    // Функция анимации закрытия
    function animatePageClose(callback) {
      const pageContent = document.querySelector('.project-page-content') || document.querySelector('.blog-page-content') || document.body;
      
      // Применяем анимацию закрытия к контенту
      pageContent.style.transition = 'opacity 0.15s ease-out, filter 0.15s ease-out';
      pageContent.style.opacity = '0.4';
      pageContent.style.filter = 'blur(24px)';
      
      // Выполняем callback после анимации
      const timeoutId = setTimeout(callback, 150);
      
      // Защита от зависания - сброс анимации через 1 секунду
      setTimeout(() => {
        if (pageContent.style.opacity === '0.4') {
          console.warn('Animation stuck, resetting...');
          pageContent.style.opacity = '';
          pageContent.style.filter = '';
          pageContent.style.transition = '';
        }
      }, 1000);
    }
    
    // Обработчик клика
    closeButton.addEventListener('click', function() {
      console.log('Close button clicked');
      
      // Определяем URL для возврата
      let returnUrl;
      if (finalSource === 'home') {
        returnUrl = '/';
      } else if (finalSource === 'blog') {
        returnUrl = '/blog';
      } else {
        returnUrl = '/projects';
      }
      
      // Запускаем анимацию закрытия
      animatePageClose(() => {
        // Устанавливаем флаг что переход произошел через кнопку закрытия
        sessionStorage.setItem('disablePageAnimations', 'true');
        
        // Очищаем сохраненные источники
        sessionStorage.removeItem('projectNavigationSource');
        sessionStorage.removeItem('blogNavigationSource');
        
        // Используем history.back() для возврата к предыдущей странице
        if (window.history.length > 1) {
          window.history.back();
        } else {
          // Fallback если нет истории
          window.location.href = returnUrl;
        }
      });
    });
    
    // ESC для закрытия
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        console.log('Escape pressed');
        
        // Определяем URL для возврата
        const finalSource = fromSource || sessionStorage.getItem('projectNavigationSource') || sessionStorage.getItem('blogNavigationSource');
        let returnUrl;
        if (finalSource === 'home') {
          returnUrl = '/';
        } else if (finalSource === 'blog') {
          returnUrl = '/blog';
        } else {
          returnUrl = '/projects';
        }
        
        // Запускаем анимацию закрытия
        animatePageClose(() => {
          // Устанавливаем флаг что переход произошел через кнопку закрытия
          sessionStorage.setItem('disablePageAnimations', 'true');
          
          // Очищаем сохраненные источники
          sessionStorage.removeItem('projectNavigationSource');
          sessionStorage.removeItem('blogNavigationSource');
          
          // Используем history.back() для возврата к предыдущей странице
          if (window.history.length > 1) {
            window.history.back();
          } else {
            // Fallback если нет истории
            window.location.href = returnUrl;
          }
        });
      }
    });
  }
  
  // Обработчик события popstate для корректной работы кнопки "назад"
  window.addEventListener('popstate', function(event) {
    // Сбрасываем возможные висящие анимации
    const pageContent = document.querySelector('.project-page-content') || document.querySelector('.blog-page-content') || document.body;
    if (pageContent && pageContent.style.opacity === '0.4') {
      pageContent.style.opacity = '';
      pageContent.style.filter = '';
      pageContent.style.transition = '';
    }
  });

  // Инициализация
  document.addEventListener('DOMContentLoaded', initCloseButton);
  document.addEventListener('astro:page-load', initCloseButton);
</script>

<style>
  .header-close-button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 62px;
    height: 34px;
    padding: 5px 20px;
    background: rgba(235, 235, 235, 0.4);
    backdrop-filter: blur(24px);
    border: none;
    border-radius: 9999px;
    color: rgb(7, 7, 7);
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    user-select: none;
    overflow: hidden;
    font-family: 'Die Grotesk B', sans-serif;
    font-weight: 400;
    font-size: 16px;
    line-height: 1.5;
  }
  
  .header-close-button:hover {
    background: rgba(235, 235, 235, 0.6);
  }
  
  /* Темная тема */
  @media (prefers-color-scheme: dark) {
    .header-close-button {
      background: rgba(20, 20, 20, 0.4);
      color: rgb(248, 248, 248);
    }
    
    .header-close-button:hover {
      background: rgba(20, 20, 20, 0.6);
    }
  }

  :global(html.dark) .header-close-button {
    background: rgba(20, 20, 20, 0.4);
    color: rgb(248, 248, 248);
  }
  
  :global(html.dark) .header-close-button:hover {
    background: rgba(20, 20, 20, 0.6);
  }
</style>
